<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BountyScan</title>
    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script async src="https://scripts.simpleanalyticscdn.com/latest.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        /* Animated background */
        .bg-animation {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
            background: linear-gradient(45deg, #0a0a0a, #1a0f1f, #0f1a1a);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Floating particles */
        .particle {
            position: fixed;
            pointer-events: none;
            opacity: 0.5;
            animation: float 20s infinite linear;
        }

        @keyframes float {
            from {
                transform: translateY(100vh) translateX(0);
            }
            to {
                transform: translateY(-10vh) translateX(100px);
            }
        }

        /* Header */
        header {
            background: rgba(15, 15, 15, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
            animation: slideDown 0.5s ease-out;
        }

        @keyframes slideDown {
            from {
                transform: translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff3366, #ff6633);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 30px rgba(255, 51, 102, 0.5);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        .wallet-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .wallet-address {
            font-family: monospace;
            font-size: 0.9rem;
            color: #888;
            background: rgba(255, 255, 255, 0.05);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        /* Buttons */
        .btn {
            background: linear-gradient(45deg, #ff3366, #ff6633);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(255, 51, 102, 0.4);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:active::before {
            width: 300px;
            height: 300px;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid rgba(255, 255, 255, 0.2);
            color: white;
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.4);
            box-shadow: 0 5px 20px rgba(255, 255, 255, 0.1);
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4444, #ff6666);
        }

        .btn-danger:hover {
            box-shadow: 0 10px 30px rgba(255, 68, 68, 0.4);
        }

        /* Main content */
        main {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            animation: fadeIn 0.8s ease-out 0.3s both;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Hero section */
        .hero {
            text-align: center;
            padding: 4rem 0;
            position: relative;
        }

        .hero h1 {
            font-size: 4rem;
            margin-bottom: 1rem;
            background: linear-gradient(45deg, #ff3366, #ff6633, #ffcc33);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: textGlow 3s ease-in-out infinite;
        }

        @keyframes textGlow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .hero p {
            font-size: 1.2rem;
            color: #aaa;
            margin-bottom: 2rem;
            opacity: 0;
            animation: fadeInUp 0.8s ease-out 0.6s forwards;
        }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
            from {
                opacity: 0;
                transform: translateY(20px);
            }
        }

        /* Stats cards */
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin: 3rem 0;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 2rem;
            text-align: center;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, rgba(255, 51, 102, 0.1) 0%, transparent 70%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .stat-card:hover::before {
            opacity: 1;
        }

        .stat-card:hover {
            transform: translateY(-5px);
            border-color: rgba(255, 51, 102, 0.5);
            box-shadow: 0 20px 40px rgba(255, 51, 102, 0.2);
        }

        .stat-value {
            font-size: 3rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff3366, #ff6633);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .stat-label {
            color: #888;
            margin-top: 0.5rem;
        }

        /* Loading spinner */
        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top-color: #ff3366;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            z-index: 1000;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .modal.show {
            display: flex;
            opacity: 1;
        }

        .modal-content {
            background: rgba(20, 20, 20, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            transform: scale(0.9);
            transition: transform 0.3s ease;
        }

        .modal.show .modal-content {
            transform: scale(1);
        }

        /* Form styles */
        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            margin-bottom: 0.5rem;
            color: #aaa;
            font-size: 0.9rem;
        }

        .form-input {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: white;
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-input:focus {
            outline: none;
            border-color: #ff3366;
            background: rgba(255, 255, 255, 0.08);
            box-shadow: 0 0 20px rgba(255, 51, 102, 0.2);
        }

        .system-info {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .error-message {
            color: #ff4444;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .success-message {
            color: #44ff44;
            font-size: 0.9rem;
            margin-top: 0.5rem;
        }

        .bounty-list {
            display: grid;
            gap: 1rem;
            margin-top: 2rem;
        }

        .bounty-item {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 1.5rem;
            transition: all 0.3s ease;
        }

        .bounty-item:hover {
            transform: translateY(-2px);
            border-color: rgba(255, 51, 102, 0.5);
            box-shadow: 0 10px 30px rgba(255, 51, 102, 0.2);
        }

        .bounty-header {
            display: flex;
            justify-content: space-between;
            align-items: start;
            margin-bottom: 1rem;
        }

        .bounty-amount {
            font-size: 1.5rem;
            font-weight: bold;
            background: linear-gradient(45deg, #ff3366, #ff6633);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .bounty-details {
            color: #aaa;
            font-size: 0.9rem;
            line-height: 1.6;
        }

        .excluded-addresses {
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.85rem;
            color: #888;
        }

        /* Network indicator */
        .network-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            margin-right: 12px;
            font-size: 0.85rem;
        }
        
        .network-indicator::before {
            content: '';
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .network-connected::before {
            background-color: #44ff44;
        }
        
        .network-disconnected::before {
            background-color: #ff4444;
        }

        /* Toast notifications */
        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 8px;
            background: rgba(30, 30, 30, 0.9);
            border-left: 4px solid;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            transform: translateX(120%);
            transition: transform 0.3s ease;
            max-width: 400px;
        }
        
        .toast.show {
            transform: translateX(0);
        }
        
        .toast-success {
            border-color: #44ff44;
        }
        
        .toast-error {
            border-color: #ff4444;
        }
        
        .toast-info {
            border-color: #4488ff;
        }
        
        .toast-header {
            font-weight: bold;
            margin-bottom: 0.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .toast-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 1.2rem;
        }

        .network-node-list {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .network-node-item {
            padding: 0.25rem 0;
            color: #aaa;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .hero h1 {
                font-size: 2.5rem;
            }
            
            nav {
                flex-wrap: wrap;
                gap: 1rem;
            }
            
            .wallet-address {
                font-size: 0.8rem;
            }
            
            .wallet-info {
                flex-wrap: wrap;
            }
        }
    </style>
</head>
<body>
    <div class="bg-animation"></div>
    
    <!-- Floating particles -->
    <script>
        for (let i = 0; i < 20; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 20 + 's';
            particle.style.width = particle.style.height = Math.random() * 4 + 2 + 'px';
            particle.style.background = `rgba(74, ${144 + Math.random() * 50}, ${226 + Math.random() * 30}, 0.8)`;
            particle.style.borderRadius = '50%';
            particle.style.boxShadow = `0 0 ${Math.random() * 10 + 5}px rgba(74, 144, 226, 0.5)`;
            document.body.appendChild(particle);
        }
    </script>

    <header>
        <nav>
            <div class="logo">BountyScan</div>
            <div class="wallet-info">
                <span class="network-indicator" id="networkIndicator" style="display: none;">
                    <span id="networkStatus"></span>
                </span>
                <span class="wallet-address" id="walletAddress" style="display: none;"></span>
                <button class="btn-secondary btn" id="faucetBtn" style="display: none;" onclick="window.open('https://pyropechain.com/faucet', '_blank')">Get Test ETH</button>
                <button class="btn" id="connectWallet" onclick="window.connectWallet()">Connect Wallet</button>
            </div>
        </nav>
    </header>

    <main>
        <section class="hero">
            <h1>The Network Wars: Claim Phase</h1>
            <p>Claim rewards for deploying Network Nodes in specific solar systems</p>
            <div id="mainActions" style="margin-top: 2rem;">
                <button class="btn" style="margin-right: 1rem;" onclick="showCreateBounty()" id="createBountyBtn" disabled>Create Bounty</button>
                <button class="btn-secondary btn" style="margin-right: 1rem;" onclick="showAllBounties()">View All Bounties</button>
                <button class="btn-secondary btn" onclick="showMyBounties()" id="myBountiesBtn" disabled>My Bounties</button>
            </div>
            <div style="margin-top: 1rem; color: #888; font-size: 0.9rem;" id="walletRequiredMsg">
                Connect your wallet to create bounties or view your personal bounties
            </div>
        </section>

        <!-- Dynamic Content Area -->
        <section id="dynamicContent" style="margin-top: 3rem;"></section>

        <section class="stats" id="stats" style="display: none;">
            <div class="stat-card">
                <div class="stat-value" id="activeBountiesCount">0</div>
                <div class="stat-label">Active Bounties</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalValueLocked">0 ETH</div>
                <div class="stat-label">Total Value Locked</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="claimedBountiesCount">0</div>
                <div class="stat-label">Bounties Claimed</div>
            </div>
        </section>
    </main>

    <!-- Connection Modal -->
    <div class="modal" id="connectionModal">
        <div class="modal-content">
            <h2 style="margin-bottom: 1rem;">Connecting to Wallet</h2>
            <div style="display: flex; justify-content: center; margin: 2rem 0;">
                <div class="spinner"></div>
            </div>
            <p style="text-align: center; color: #888;" id="modalMessage">Please approve the connection in your wallet...</p>
        </div>
    </div>
    
    <!-- Toast container -->
    <div id="toastContainer"></div>

    <script>
        (function() {
            // Contract ABI
            const NETWORKNODE_BOUNTY_ABI = [
                "function createBounty(uint256 _systemId, string memory _systemName, address[] memory _existingNetworkNodeOwners) payable",
                "function claimBounty(uint256 _bountyId)",
                "function cancelBounty(uint256 _bountyId)",
                "function getBountiesOnSystem(uint256 _systemId) view returns (uint256[])",
                "function getActiveBountiesOnSystem(uint256 _systemId) view returns (uint256[])",
                "function getTotalBountyOnSystem(uint256 _systemId) view returns (uint256)",
                "function getSystemIdByName(string memory _systemName) view returns (uint256)",
                "function getBountyExcludedAddresses(uint256 _bountyId) view returns (address[])",
                "function canAddressClaimBounty(uint256 _bountyId, address _address) view returns (bool)",
                "function bounties(uint256) view returns (address creator, uint256 systemId, string systemName, uint256 amount, uint256 createdAt, bool claimed, address claimedBy)",
                "function bountyCounter() view returns (uint256)",
                "event BountyCreated(uint256 indexed bountyId, uint256 indexed systemId, string systemName, address indexed creator, uint256 amount, address[] excludedAddresses)",
                "event BountyClaimed(uint256 indexed bountyId, address indexed claimer, uint256 systemId)",
                "event BountyCancelled(uint256 indexed bountyId)"
            ];
            
            const NETWORKNODE_BOUNTY_ADDRESS = "0x1032089853ae8fc4249213d4834e50cb86D018E0";
            const EVE_API_BASE = "https://blockchain-gateway-stillness.live.tech.evefrontier.com";

            // Pyrope Testnet configuration
            const PYROPE_CONFIG = {
                chainId: '0xa9d11', // 695569 in hex
                chainIdDecimal: 695569,
                chainName: 'Pyrope Testnet',
                nativeCurrency: {
                    name: 'Ethereum',
                    symbol: 'ETH',
                    decimals: 18
                },
                rpcUrls: ['https://rpc.pyropechain.com'],
                blockExplorerUrls: ['https://explorer.pyropechain.com']
            };

            // Global variables
            let provider = null;
            let signer = null;
            let userAddress = null;
            let bountyContract = null;
            let solarSystemsMapping = null;
            
            // Load solar systems mapping
            async function loadSolarSystemsMapping() {
                if (solarSystemsMapping) return solarSystemsMapping;
                
                try {
                    const response = await fetch('./solar_systems_mapping.json');
                    if (!response.ok) throw new Error('Failed to load solar systems mapping');
                    solarSystemsMapping = await response.json();
                    return solarSystemsMapping;
                } catch (error) {
                    console.error('Error loading solar systems mapping:', error);
                    showToast('Failed to load solar systems database', 'error');
                    return null;
                }
            }

            // Fuzzy search function
            function fuzzySearch(searchTerm, systemsMapping, maxResults = 10) {
                if (!searchTerm || !systemsMapping) return [];
                
                const searchLower = searchTerm.toLowerCase();
                const results = [];
                
                for (const [systemName, systemId] of Object.entries(systemsMapping)) {
                    const nameLower = systemName.toLowerCase();
                    let score = 0;
                    
                    // Exact match gets highest score
                    if (nameLower === searchLower) {
                        score = 1000;
                    }
                    // Starts with search term
                    else if (nameLower.startsWith(searchLower)) {
                        score = 900;
                    }
                    // Contains search term
                    else if (nameLower.includes(searchLower)) {
                        score = 800;
                    }
                    // Fuzzy matching - check if all characters in search term appear in order
                    else {
                        let searchIndex = 0;
                        let matches = 0;
                        
                        for (let i = 0; i < nameLower.length && searchIndex < searchLower.length; i++) {
                            if (nameLower[i] === searchLower[searchIndex]) {
                                matches++;
                                searchIndex++;
                            }
                        }
                        
                        if (matches === searchLower.length) {
                            score = 700 - (nameLower.length - searchLower.length) * 10; // Prefer shorter matches
                        }
                    }
                    
                    if (score > 0) {
                        results.push({ name: systemName, id: systemId, score });
                    }
                }
                
                // Sort by score and return top results
                return results
                    .sort((a, b) => b.score - a.score)
                    .slice(0, maxResults);
            }
            function showToast(message, type = 'info', duration = 5000) {
                const container = document.getElementById('toastContainer');
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.innerHTML = `
                    <div class="toast-header">
                        <span>${type.charAt(0).toUpperCase() + type.slice(1)}</span>
                        <button class="toast-close">&times;</button>
                    </div>
                    <div class="toast-body">${message}</div>
                `;
                
                container.appendChild(toast);
                
                // Close button handler
                toast.querySelector('.toast-close').addEventListener('click', () => {
                    toast.remove();
                });
                
                // Auto-hide after duration
                setTimeout(() => {
                    toast.classList.add('show');
                    setTimeout(() => {
                        toast.classList.remove('show');
                        setTimeout(() => {
                            if (toast.parentNode) toast.parentNode.removeChild(toast);
                        }, 300);
                    }, duration);
                }, 10);
                
                // Show immediately
                setTimeout(() => toast.classList.add('show'), 50);
            }

            // Initialize contract when wallet connects
            function initializeContract() {
                if (provider && signer) {
                    bountyContract = new window.ethers.Contract(NETWORKNODE_BOUNTY_ADDRESS, NETWORKNODE_BOUNTY_ABI, signer);
                    updateStats();
                }
            }

            // Update stats from blockchain
            async function updateStats() {
                if (!bountyContract) return;

                try {
                    // Get total bounty count
                    const totalCount = await bountyContract.bountyCounter();
                    
                    let activeCount = 0;
                    let claimedCount = 0;
                    let totalValue = window.ethers.BigNumber.from(0);

                    // Iterate through all bounties
                    for (let i = 0; i < totalCount; i++) {
                        const bounty = await bountyContract.bounties(i);
                        if (bounty.claimed) {
                            claimedCount++;
                        } else {
                            activeCount++;
                            totalValue = totalValue.add(bounty.amount);
                        }
                    }

                    // Update UI
                    document.getElementById('activeBountiesCount').textContent = activeCount;
                    document.getElementById('totalValueLocked').textContent = 
                        window.ethers.utils.formatEther(totalValue).slice(0, 8) + ' ETH';
                    document.getElementById('claimedBountiesCount').textContent = claimedCount;
                } catch (error) {
                    console.error('Error updating stats:', error);
                    showToast('Failed to update stats: ' + error.message, 'error');
                }
            }

            // Show create bounty form
            function showCreateBounty() {
                const content = document.getElementById('dynamicContent');
                content.innerHTML = `
                    <div style="max-width: 600px; margin: 0 auto;">
                        <h2 style="margin-bottom: 2rem;">Create New Bounty</h2>
                        
                        <div class="form-group">
                            <label class="form-label">Solar System Name or ID</label>
                            <input type="text" id="systemInput" class="form-input" 
                                   placeholder="e.g., U6R-506 or 30014334" 
                                   autocomplete="off">
                            <div id="searchResults" style="display: none;"></div>
                            <div id="systemInfo"></div>
                            <div id="systemError" class="error-message"></div>
                        </div>

                        <div class="form-group">
                            <label class="form-label">Bounty Amount (ETH)</label>
                            <input type="number" id="bountyAmount" class="form-input" 
                                   placeholder="0.1" step="0.01" min="0.001">
                            <div id="amountError" class="error-message"></div>
                        </div>

                        <button class="btn" onclick="createBounty()" id="createBountyBtn">Create Bounty</button>
                        <div id="createStatus" style="margin-top: 1rem;"></div>
                    </div>
                `;
                
                // Load solar systems mapping when form is shown
                loadSolarSystemsMapping();
                
                // Add event listeners after DOM is updated
                setTimeout(() => {
                    const systemInput = document.getElementById('systemInput');
                    if (systemInput) {
                        systemInput.addEventListener('input', (e) => {
                            window.searchSolarSystems(e.target.value);
                        });
                        
                        systemInput.addEventListener('change', (e) => {
                            window.lookupSystem(e.target.value);
                        });
                        
                        // Hide search results when clicking outside
                        systemInput.addEventListener('blur', () => {
                            setTimeout(() => {
                                const resultsDiv = document.getElementById('searchResults');
                                if (resultsDiv) resultsDiv.style.display = 'none';
                            }, 200); // Delay to allow clicking on results
                        });
                    }
                }, 0);
            }

            // Search solar systems with fuzzy matching
            async function searchSolarSystems(searchTerm) {
                const resultsDiv = document.getElementById('searchResults');
                
                if (!searchTerm || searchTerm.length < 2) {
                    resultsDiv.style.display = 'none';
                    return;
                }

                // Load mapping if not already loaded
                const mapping = await loadSolarSystemsMapping();
                if (!mapping) {
                    resultsDiv.style.display = 'none';
                    return;
                }

                // If it's a pure number, don't show search results (let the user enter the ID directly)
                if (/^\d+$/.test(searchTerm)) {
                    resultsDiv.style.display = 'none';
                    return;
                }

                const results = fuzzySearch(searchTerm, mapping);
                
                if (results.length === 0) {
                    resultsDiv.style.display = 'none';
                    return;
                }

                let html = '<div style="background: rgba(0, 0, 0, 0.9); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; margin-top: 0.5rem; max-height: 200px; overflow-y: auto; z-index: 1000; position: relative;">';
                
                results.forEach(result => {
                    html += `
                        <div style="padding: 0.75rem; border-bottom: 1px solid rgba(255, 255, 255, 0.1); cursor: pointer; transition: background 0.2s;"
                             onmouseover="this.style.background='rgba(255, 51, 102, 0.1)'"
                             onmouseout="this.style.background='transparent'"
                             onclick="selectSolarSystem('${result.name}', ${result.id})">
                            <div style="font-weight: bold; color: #fff;">${result.name}</div>
                            <div style="font-size: 0.85rem; color: #888;">ID: ${result.id}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
                resultsDiv.innerHTML = html;
                resultsDiv.style.display = 'block';
            }

            // Select a solar system from search results
            async function selectSolarSystem(systemName, systemId) {
                const input = document.getElementById('systemInput');
                const resultsDiv = document.getElementById('searchResults');
                
                input.value = systemName;
                resultsDiv.style.display = 'none';
                
                // Automatically lookup the selected system
                await lookupSystem(systemId.toString());
            }

            // Expose functions to global scope immediately
            window.searchSolarSystems = searchSolarSystems;
            window.selectSolarSystem = selectSolarSystem;
            window.lookupSystem = lookupSystem;

            // Lookup system info from EVE API
            async function lookupSystem(input) {
                const infoDiv = document.getElementById('systemInfo');
                const errorDiv = document.getElementById('systemError');
                
                if (!input) {
                    errorDiv.textContent = 'Please enter a system name or ID';
                    infoDiv.innerHTML = '';
                    return;
                }

                errorDiv.textContent = '';
                infoDiv.innerHTML = '<div class="spinner"></div>';

                try {
                    let systemId;
                    let systemData;
                    
                    if (/^\d+$/.test(input)) {
                        // Input is numeric, treat as ID
                        systemId = input;
                    } else {
                        // Input is name, look it up in mapping
                        const mapping = await loadSolarSystemsMapping();
                        if (mapping && mapping[input]) {
                            systemId = mapping[input].toString();
                        } else {
                            errorDiv.textContent = 'System not found in database. Please check the name or use a system ID.';
                            infoDiv.innerHTML = '';
                            return;
                        }
                    }

                    const response = await fetch(`${EVE_API_BASE}/v2/solarsystems/${systemId}`);
                    if (!response.ok) throw new Error('System not found');
                    
                    systemData = await response.json();
                    
                    // Find existing NetworkNodes
                    const networkNodes = systemData.smartAssemblies?.filter(assembly => 
                        assembly.type === 'NetworkNode'
                    ) || [];
                    
                    // Store system data for later use
                    window.currentSystemData = {
                        id: systemData.id,
                        name: systemData.name,
                        networkNodeOwners: networkNodes.map(node => node.owner.address.toLowerCase())
                    };
                    
                    infoDiv.innerHTML = `
                        <div class="system-info">
                            <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem;">
                                ${systemData.name} (${systemData.id})
                            </div>
                            <div style="color: #888; font-size: 0.9rem;">
                                Region ID: ${systemData.regionId}<br>
                                Smart Assemblies: ${systemData.smartAssemblies?.length || 0}<br>
                                Existing Network Nodes: ${networkNodes.length}
                            </div>
                            ${networkNodes.length > 0 ? `
                                <div class="network-node-list">
                                    <div style="font-weight: bold; margin-bottom: 0.25rem;">Current Network Node Owners:</div>
                                    ${networkNodes.map(node => `
                                        <div class="network-node-item">
                                            ${node.owner.name} (${node.owner.address.slice(0, 6)}...${node.owner.address.slice(-4)})
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    `;
                } catch (error) {
                    errorDiv.textContent = 'System not found or error loading data';
                    infoDiv.innerHTML = '';
                    window.currentSystemData = null;
                }
            }

            // Create bounty transaction
            async function createBounty() {
                const bountyAmount = document.getElementById('bountyAmount').value;
                const statusDiv = document.getElementById('createStatus');
                const createBtn = document.getElementById('createBountyBtn');

                // Validation
                if (!window.currentSystemData) {
                    statusDiv.innerHTML = '<div class="error-message">Please select a valid system first</div>';
                    return;
                }

                if (!bountyAmount || parseFloat(bountyAmount) <= 0) {
                    statusDiv.innerHTML = '<div class="error-message">Invalid bounty amount</div>';
                    return;
                }

                try {
                    createBtn.disabled = true;
                    statusDiv.innerHTML = '<div class="spinner"></div> Creating bounty...';

                    const tx = await bountyContract.createBounty(
                        window.currentSystemData.id,
                        window.currentSystemData.name,
                        window.currentSystemData.networkNodeOwners,
                        {
                            value: window.ethers.utils.parseEther(bountyAmount)
                        }
                    );

                    statusDiv.innerHTML = '<div class="spinner"></div> Waiting for confirmation...';
                    await tx.wait();

                    statusDiv.innerHTML = '<div class="success-message">Bounty created successfully!</div>';
                    updateStats();
                    showToast('Bounty created successfully!', 'success');
                    
                    // Clear form
                    setTimeout(() => {
                        document.getElementById('systemInput').value = '';
                        document.getElementById('bountyAmount').value = '';
                        document.getElementById('systemInfo').innerHTML = '';
                        statusDiv.innerHTML = '';
                        window.currentSystemData = null;
                        createBtn.disabled = false;
                    }, 3000);

                } catch (error) {
                    console.error('Error creating bounty:', error);
                    statusDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                    showToast('Failed to create bounty: ' + error.message, 'error');
                    createBtn.disabled = false;
                }
            }

            // Show all bounties
            async function showAllBounties() {
                const content = document.getElementById('dynamicContent');
                content.innerHTML = '<div class="spinner"></div> Loading bounties...';
            
                try {
                    // Initialize read-only contract if not connected
                    let contractToUse = bountyContract;
                    if (!contractToUse) {
                        const readOnlyProvider = new window.ethers.providers.JsonRpcProvider('https://rpc.pyropechain.com');
                        contractToUse = new window.ethers.Contract(NETWORKNODE_BOUNTY_ADDRESS, NETWORKNODE_BOUNTY_ABI, readOnlyProvider);
                    }
                    
                    const totalCount = await contractToUse.bountyCounter();
                    const bounties = [];
                    
                    // Group bounties by system
                    const systemBounties = {};
                    
                    for (let i = 0; i < totalCount; i++) {
                        const bounty = await contractToUse.bounties(i);
                        if (!bounty.claimed) {
                            const systemId = bounty.systemId.toString();
                            if (!systemBounties[systemId]) {
                                systemBounties[systemId] = {
                                    systemId: systemId,
                                    systemName: bounty.systemName,
                                    bounties: [],
                                    totalValue: window.ethers.BigNumber.from(0)
                                };
                            }
                            systemBounties[systemId].bounties.push({
                                id: i,
                                ...bounty
                            });
                            systemBounties[systemId].totalValue = systemBounties[systemId].totalValue.add(bounty.amount);
                        }
                    }

                    if (Object.keys(systemBounties).length === 0) {
                        content.innerHTML = '<div style="text-align: center; color: #888;">No active bounties</div>';
                        return;
                    }

                    let html = '<h2 style="margin-bottom: 2rem;">Active Bounties by System</h2><div class="bounty-list">';
                    
                    for (const systemData of Object.values(systemBounties)) {
                        html += `
                            <div class="bounty-item">
                                <div class="bounty-header">
                                    <div>
                                        <div style="font-weight: bold; font-size: 1.3rem; margin-bottom: 0.5rem;">
                                            ${systemData.systemName} (${systemData.systemId})
                                        </div>
                                        <div class="bounty-amount">
                                            Total: ${window.ethers.utils.formatEther(systemData.totalValue)} ETH
                                        </div>
                                        <div class="bounty-details" style="margin-top: 0.5rem;">
                                            ${systemData.bounties.length} active bounty${systemData.bounties.length > 1 ? 'ies' : ''}
                                        </div>
                                    </div>
                                    <button class="btn-secondary btn" onclick="viewSystemBounties('${systemData.systemId}', '${systemData.systemName}')">
                                        View Details
                                    </button>
                                </div>
                            </div>
                        `;
                    }
                    html += '</div>';
                    content.innerHTML = html;

                } catch (error) {
                    console.error('Error loading bounties:', error);
                    content.innerHTML = '<div class="error-message">Error loading bounties</div>';
                }
            }

            // View bounties for a specific system
            async function viewSystemBounties(systemId, systemName) {
                const content = document.getElementById('dynamicContent');
                content.innerHTML = '<div class="spinner"></div> Loading system bounties...';

                try {
                    // Initialize read-only contract if not connected
                    let contractToUse = bountyContract;
                    if (!contractToUse) {
                        const readOnlyProvider = new window.ethers.providers.JsonRpcProvider('https://rpc.pyropechain.com');
                        contractToUse = new window.ethers.Contract(NETWORKNODE_BOUNTY_ADDRESS, NETWORKNODE_BOUNTY_ABI, readOnlyProvider);
                    }

                    // Get current system info
                    let currentNetworkNodes = [];
                    try {
                        const response = await fetch(`${EVE_API_BASE}/v2/solarsystems/${systemId}`);
                        if (response.ok) {
                            const systemData = await response.json();
                            currentNetworkNodes = systemData.smartAssemblies?.filter(assembly => 
                                assembly.type === 'NetworkNode'
                            ) || [];
                        }
                    } catch (e) {
                        console.error('Error fetching system data:', e);
                    }

                    const bountyIds = await contractToUse.getBountiesOnSystem(systemId);
                    const bounties = [];
                    
                    for (const bountyId of bountyIds) {
                        const bounty = await contractToUse.bounties(bountyId);
                        if (!bounty.claimed) {
                            const excludedAddresses = await contractToUse.getBountyExcludedAddresses(bountyId);
                            const canClaim = userAddress ? await contractToUse.canAddressClaimBounty(bountyId, userAddress) : false;

                            bounties.push({
                                id: bountyId,
                                ...bounty,
                                excludedAddresses,
                                canClaim
                            });
                        }
                    }

                    let html = `
                        <div style="margin-bottom: 2rem;">
                            <button class="btn-secondary btn" onclick="showAllBounties()">‚Üê Back to All Bounties</button>
                        </div>
                        <h2 style="margin-bottom: 1rem;">${systemName} (${systemId})</h2>
                    `;

                    if (currentNetworkNodes.length > 0) {
                        html += `
                            <div class="system-info" style="margin-bottom: 2rem;">
                                <div style="font-weight: bold; margin-bottom: 0.5rem;">Current Network Nodes (${currentNetworkNodes.length}):</div>
                                ${currentNetworkNodes.map(node => `
                                    <div class="network-node-item">
                                        ${node.owner.name} (${node.owner.address.slice(0, 6)}...${node.owner.address.slice(-4)})
                                    </div>
                                `).join('')}
                            </div>
                        `;
                    }

                    html += '<div class="bounty-list">';

                    for (const bounty of bounties) {
                        const isMyBounty = bounty.creator.toLowerCase() === userAddress?.toLowerCase();
                        
                        html += `
                            <div class="bounty-item">
                                <div class="bounty-header">
                                    <div style="flex: 1;">
                                        <div class="bounty-amount">${window.ethers.utils.formatEther(bounty.amount)} ETH</div>
                                        <div class="bounty-details">
                                            Bounty ID: #${bounty.id}<br>
                                            Created by: ${bounty.creator.slice(0, 6)}...${bounty.creator.slice(-4)} ${isMyBounty ? '(You)' : ''}<br>
                                            Created: ${new Date(bounty.createdAt.toNumber() * 1000).toLocaleString()}
                                        </div>
                                        ${bounty.excludedAddresses.length > 0 ? `
                                            <div class="excluded-addresses">
                                                <strong>Excluded addresses (had NetworkNodes when created):</strong><br>
                                                ${bounty.excludedAddresses.map(addr => 
                                                    `${addr.slice(0, 6)}...${addr.slice(-4)}`
                                                ).join(', ')}
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div style="display: flex; flex-direction: column; gap: 0.5rem;">
                                        ${userAddress && bounty.canClaim ? `
                                            <button class="btn" onclick="claimBounty(${bounty.id})">
                                                Claim Bounty
                                            </button>
                                        ` : userAddress && !bounty.canClaim ? `
                                            <button class="btn" disabled style="opacity: 0.5; cursor: not-allowed;">
                                                Not Eligible
                                            </button>
                                        ` : ''}
                                        ${isMyBounty ? `
                                            <button class="btn-danger btn" onclick="cancelBounty(${bounty.id})">
                                                Cancel
                                            </button>
                                        ` : ''}
                                    </div>
                                </div>
                            </div>
                        `;
                    }
                    
                    html += '</div>';
                    content.innerHTML = html;

                } catch (error) {
                    console.error('Error loading system bounties:', error);
                    content.innerHTML = '<div class="error-message">Error loading bounties</div>';
                }
            }

            // Show user's bounties
            async function showMyBounties() {
                const content = document.getElementById('dynamicContent');
                content.innerHTML = '<div class="spinner"></div> Loading your bounties...';

                try {
                    const totalCount = await bountyContract.bountyCounter();
                    const createdBounties = [];
                    const claimableBounties = [];
                    
                    for (let i = 0; i < totalCount; i++) {
                        const bounty = await bountyContract.bounties(i);
                        
                        if (bounty.creator.toLowerCase() === userAddress.toLowerCase()) {
                            createdBounties.push({
                                id: i,
                                ...bounty
                            });
                        } else if (!bounty.claimed) {
                            const canClaim = await bountyContract.canAddressClaimBounty(i, userAddress);
                            if (canClaim) {
                                claimableBounties.push({
                                    id: i,
                                    ...bounty
                                });
                            }
                        }
                    }

                    let html = '<h2 style="margin-bottom: 2rem;">My Bounties</h2>';
                    
                    if (createdBounties.length > 0) {
                        html += '<h3 style="margin-bottom: 1rem;">Bounties You Created</h3><div class="bounty-list" style="margin-bottom: 3rem;">';
                        
                        for (const bounty of createdBounties) {
                            html += `
                                <div class="bounty-item">
                                    <div class="bounty-header">
                                        <div>
                                            <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem;">
                                                ${bounty.systemName} (${bounty.systemId})
                                            </div>
                                            <div class="bounty-amount">${window.ethers.utils.formatEther(bounty.amount)} ETH</div>
                                            <div class="bounty-details">
                                                Status: ${bounty.claimed ? `Claimed by ${bounty.claimedBy.slice(0, 6)}...${bounty.claimedBy.slice(-4)}` : 'Active'}<br>
                                                Created: ${new Date(bounty.createdAt.toNumber() * 1000).toLocaleString()}
                                            </div>
                                        </div>
                                        ${!bounty.claimed ? `
                                            <button class="btn-danger btn" onclick="cancelBounty(${bounty.id})">
                                                Cancel Bounty
                                            </button>
                                        ` : ''}
                                    </div>
                                </div>
                            `;
                        }
                        html += '</div>';
                    }
                    
                    if (claimableBounties.length > 0) {
                        html += '<h3 style="margin-bottom: 1rem;">Bounties You Can Claim</h3><div class="bounty-list">';
                        
                        for (const bounty of claimableBounties) {
                            html += `
                                <div class="bounty-item">
                                    <div class="bounty-header">
                                        <div>
                                            <div style="font-weight: bold; font-size: 1.1rem; margin-bottom: 0.5rem;">
                                                ${bounty.systemName} (${bounty.systemId})
                                            </div>
                                            <div class="bounty-amount">${window.ethers.utils.formatEther(bounty.amount)} ETH</div>
                                            <div class="bounty-details">
                                                Created by: ${bounty.creator.slice(0, 6)}...${bounty.creator.slice(-4)}<br>
                                                Created: ${new Date(bounty.createdAt.toNumber() * 1000).toLocaleString()}
                                            </div>
                                        </div>
                                        <button class="btn" onclick="claimBounty(${bounty.id})">
                                            Claim Bounty
                                        </button>
                                    </div>
                                </div>
                            `;
                        }
                        html += '</div>';
                    }
                    
                    if (createdBounties.length === 0 && claimableBounties.length === 0) {
                        html += '<div style="text-align: center; color: #888; margin-top: 2rem;">You have no bounties yet</div>';
                    }
                    
                    content.innerHTML = html;

                } catch (error) {
                    console.error('Error loading bounties:', error);
                    content.innerHTML = '<div class="error-message">Error loading bounties</div>';
                }
            }

            // Claim bounty
            async function claimBounty(bountyId) {
                try {
                    // First, fetch the bounty details to get the system ID
                    const bounty = await bountyContract.bounties(bountyId);

                    showToast('Verifying NetworkNode ownership...', 'info');

                    // Fetch current system data from EVE API
                    const response = await fetch(`${EVE_API_BASE}/v2/solarsystems/${bounty.systemId}`);
                    if (!response.ok) {
                        throw new Error('Failed to verify system data');
                    }

                    const systemData = await response.json();

                    // Check if user has a NetworkNode in this system
                    const userHasNetworkNode = systemData.smartAssemblies?.some(assembly => 
                        assembly.type === 'NetworkNode' && 
                        assembly.owner.address.toLowerCase() === userAddress.toLowerCase()
                    );

                    if (!userHasNetworkNode) {
                        showToast('You must deploy a NetworkNode in this system before claiming the bounty!', 'error');
                        return;
                    }

                    // Check if the NetworkNode was deployed after the bounty was created
                    const bountyCreatedTime = bounty.createdAt.toNumber() * 1000; // Convert to milliseconds

                    // Note: The EVE API doesn't seem to provide deployment timestamps for smart assemblies
                    // So we can only verify current ownership, not deployment time
                    // This is a limitation but better than no check at all

                    if (!confirm(`Confirm NetworkNode ownership in ${bounty.systemName}?\n\nYou currently have a NetworkNode in this system. Proceed with claiming the bounty?`)) {
                        return;
                    }

                    showToast('Claiming bounty...', 'info');

                    const tx = await bountyContract.claimBounty(bountyId);

                    showToast('Waiting for confirmation...', 'info');
                    await tx.wait();

                    showToast('Bounty claimed successfully!', 'success');
                    updateStats();

                    // Refresh the current view
                    viewSystemBounties(bounty.systemId.toString(), bounty.systemName);

                } catch (error) {
                    console.error('Error claiming bounty:', error);
                    if (error.message.includes('must deploy a NetworkNode')) {
                        // Already shown toast for this error
                    } else {
                        showToast('Failed to claim bounty: ' + error.message, 'error');
                    }
                }
            }

            // Cancel bounty
            async function cancelBounty(bountyId) {
                if (!confirm('Are you sure you want to cancel this bounty? The funds will be returned to you.')) {
                    return;
                }

                try {
                    showToast('Cancelling bounty...', 'info');
                    
                    const tx = await bountyContract.cancelBounty(bountyId);
                    
                    showToast('Waiting for confirmation...', 'info');
                    await tx.wait();
                    
                    showToast('Bounty cancelled successfully!', 'success');
                    updateStats();
                    
                    // Refresh the current view
                    showMyBounties();
                    
                } catch (error) {
                    console.error('Error cancelling bounty:', error);
                    showToast('Failed to cancel bounty: ' + error.message, 'error');
                }
            }

            // Wait for ethers to load
            window.addEventListener('load', () => {
                if (!window.ethers) {
                    console.error('Ethers library failed to load');
                } else {
                    console.log('Ethers library loaded successfully');
                }
            });

            // Detect wallet provider
            function getWalletProvider() {
                if (window.ethereum) {
                    // Check for multiple providers
                    if (window.ethereum.providers?.length) {
                        // Multiple wallets installed, try to find MetaMask
                        const provider = window.ethereum.providers.find((p) => p.isMetaMask);
                        if (provider) return provider;
                        // Return first available provider
                        return window.ethereum.providers[0];
                    }
                    return window.ethereum;
                }
                return null;
            }

            // Add and switch network automatically
            async function ensurePyropeNetwork() {
                const ethereum = getWalletProvider();
                if (!ethereum) return false;
                
                try {
                    // Try to switch to Pyrope network
                    await ethereum.request({
                        method: 'wallet_switchEthereumChain',
                        params: [{ chainId: PYROPE_CONFIG.chainId }],
                    });
                    return true;
                } catch (switchError) {
                    // This error code indicates that the chain has not been added to MetaMask
                    if (switchError.code === 4902) {
                        try {
                            await ethereum.request({
                                method: 'wallet_addEthereumChain',
                                params: [PYROPE_CONFIG],
                            });
                            return true;
                        } catch (addError) {
                            showToast('Failed to add Pyrope network: ' + addError.message, 'error');
                            return false;
                        }
                    }
                    // Other errors (e.g., user rejected)
                    showToast('Failed to switch to Pyrope network: ' + switchError.message, 'error');
                    return false;
                }
            }

            // Update network indicator in UI
            function updateNetworkIndicator(chainId) {
                const indicator = document.getElementById('networkIndicator');
                const status = document.getElementById('networkStatus');
                
                if (!chainId) {
                    indicator.style.display = 'none';
                    return;
                }
                
                indicator.style.display = 'inline-flex';
                
                if (chainId === PYROPE_CONFIG.chainId) {
                    indicator.className = 'network-indicator network-connected';
                    status.textContent = 'Pyrope Testnet';
                } else {
                    indicator.className = 'network-indicator network-disconnected';
                    status.textContent = 'Wrong Network';
                }
            }

            // Connect wallet function with auto network switching
            async function connectWallet() {
                console.log('Connect wallet clicked');
                
                // Check if ethers is loaded
                if (!window.ethers) {
                    showToast('Ethers library is still loading. Please try again in a moment.', 'error');
                    return;
                }

                const modal = document.getElementById('connectionModal');
                modal.classList.add('show');
                document.getElementById('modalMessage').textContent = 'Connecting to wallet...';

                try {
                    const ethereum = getWalletProvider();
                    if (!ethereum) {
                        modal.classList.remove('show');
                        showToast('No Web3 wallet detected. Please install MetaMask or another Web3 wallet.', 'error');
                        return;
                    }

                    // Step 1: Request accounts
                    document.getElementById('modalMessage').textContent = 'Please approve account access in your wallet...';
                    const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                    userAddress = accounts[0];

                    // Step 2: Check and switch network
                    document.getElementById('modalMessage').textContent = 'Checking network configuration...';
                    const currentChainId = await ethereum.request({ method: 'eth_chainId' });
                    
                    // Update UI with current network status
                    updateNetworkIndicator(currentChainId);
                    
                    if (currentChainId !== PYROPE_CONFIG.chainId) {
                        document.getElementById('modalMessage').textContent = 'Switching to Pyrope Testnet...';
                        const success = await ensurePyropeNetwork();
                        
                        if (!success) {
                            modal.classList.remove('show');
                            return;
                        }
                        
                        // Get updated chain ID after switch
                        const newChainId = await ethereum.request({ method: 'eth_chainId' });
                        updateNetworkIndicator(newChainId);
                    }

                    // Initialize web3
                    provider = new window.ethers.providers.Web3Provider(ethereum);
                    signer = provider.getSigner();
                    
                    // Update UI
                    updateUIForConnectedWallet();
                    
                    console.log('Successfully connected:', userAddress);
                    showToast('Wallet connected successfully!', 'success');
                    
                } catch (error) {
                    console.error('Error connecting wallet:', error);
                    if (error.code === 4001) {
                        showToast('Connection cancelled by user', 'error');
                    } else {
                        showToast('Failed to connect wallet: ' + error.message, 'error');
                    }
                }

                modal.classList.remove('show');
            }

            // Update UI when wallet is connected
            function updateUIForConnectedWallet() {
                const connectBtn = document.getElementById('connectWallet');
                const addressSpan = document.getElementById('walletAddress');
                const mainActions = document.getElementById('mainActions');
                const stats = document.getElementById('stats');
                const faucetBtn = document.getElementById('faucetBtn');

                // Show shortened address
                const shortAddress = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
                addressSpan.textContent = shortAddress;
                addressSpan.style.display = 'block';

                // Show faucet button
                faucetBtn.style.display = 'block';

                // Update button
                connectBtn.textContent = 'Disconnect';
                connectBtn.onclick = disconnectWallet;

                // Show main actions and stats
                document.getElementById('createBountyBtn').disabled = false;
                document.getElementById('myBountiesBtn').disabled = false;
                document.getElementById('walletRequiredMsg').style.display = 'none';
                stats.style.display = 'grid';

                // Add hover effect to show full address
                addressSpan.title = userAddress;

                // Initialize contract
                initializeContract();
            }

            // Disconnect wallet
            function disconnectWallet() {
                provider = null;
                signer = null;
                userAddress = null;
                bountyContract = null;

                // Reset UI
                const connectBtn = document.getElementById('connectWallet');
                const addressSpan = document.getElementById('walletAddress');
                const mainActions = document.getElementById('mainActions');
                const stats = document.getElementById('stats');
                const faucetBtn = document.getElementById('faucetBtn');
                const networkIndicator = document.getElementById('networkIndicator');

                addressSpan.style.display = 'none';
                faucetBtn.style.display = 'none';
                networkIndicator.style.display = 'none';
                connectBtn.textContent = 'Connect Wallet';
                connectBtn.onclick = connectWallet;
                document.getElementById('createBountyBtn').disabled = true;
                document.getElementById('myBountiesBtn').disabled = true;
                document.getElementById('walletRequiredMsg').style.display = 'block';
                stats.style.display = 'none';
                 
                showToast('Wallet disconnected', 'info');
            }

            // Listen for account changes
            if (window.ethereum) {
                const ethereum = getWalletProvider();
                if (ethereum) {
                    ethereum.on('accountsChanged', (accounts) => {
                        if (accounts.length === 0) {
                            disconnectWallet();
                        } else if (userAddress && accounts[0] !== userAddress) {
                            userAddress = accounts[0];
                            updateUIForConnectedWallet();
                        }
                    });

                    ethereum.on('chainChanged', (chainId) => {
                        updateNetworkIndicator(chainId);
                        if (chainId !== PYROPE_CONFIG.chainId) {
                            showToast('Please switch to Pyrope Testnet to use this dapp', 'error');
                        } else {
                            // Reinitialize contract if on correct network
                            if (userAddress) {
                                initializeContract();
                            }
                        }
                    });
                }
            }

            // Initialize
            document.getElementById('connectWallet').onclick = connectWallet;

            // Auto-connect if previously connected
            window.addEventListener('load', async () => {
                // Wait for provider to be injected
                await new Promise(resolve => setTimeout(resolve, 500));
                
                const ethereum = getWalletProvider();
                if (ethereum) {
                    try {
                        const accounts = await ethereum.request({ method: 'eth_accounts' });
                        
                        if (accounts.length > 0) {
                            const chainId = await ethereum.request({ method: 'eth_chainId' });
                            
                            userAddress = accounts[0];
                            updateNetworkIndicator(chainId);
                            
                            if (chainId === PYROPE_CONFIG.chainId) {
                                provider = new window.ethers.providers.Web3Provider(ethereum);
                                signer = provider.getSigner();
                                updateUIForConnectedWallet();
                            } else {
                                // Show connected but on wrong network
                                const connectBtn = document.getElementById('connectWallet');
                                const addressSpan = document.getElementById('walletAddress');
                                const faucetBtn = document.getElementById('faucetBtn');
                                
                                // Show shortened address
                                const shortAddress = userAddress.slice(0, 6) + '...' + userAddress.slice(-4);
                                addressSpan.textContent = shortAddress;
                                addressSpan.style.display = 'block';
                                faucetBtn.style.display = 'block';
                                connectBtn.textContent = 'Disconnect';
                                connectBtn.onclick = disconnectWallet;
                                
                                showToast('Connected to wrong network. Please switch to Pyrope Testnet.', 'error');
                            }
                        }
                    } catch (error) {
                        console.error('Error checking for existing connection:', error);
                    }
                }

                // Auto-load bounties view and preload solar systems mapping
                setTimeout(() => {
                    showAllBounties();
                    loadSolarSystemsMapping(); // Preload the mapping for faster searches
                }, 1000);
            });

            // Expose necessary functions to global scope
            window.connectWallet = connectWallet;
            window.disconnectWallet = disconnectWallet;
            window.showCreateBounty = showCreateBounty;
            window.showAllBounties = showAllBounties;
            window.showMyBounties = showMyBounties;
            window.viewSystemBounties = viewSystemBounties;
            window.createBounty = createBounty;
            window.claimBounty = claimBounty;
            window.cancelBounty = cancelBounty;

            // Set up button click handler after exposing functions
            document.addEventListener('DOMContentLoaded', () => {
                document.getElementById('connectWallet').onclick = connectWallet;
            });
        })();
    </script>
</body>
</html>
